# -*- coding: utf-8 -*-
"""Untitled50.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XKRJlaLMXKhI3GiiPCOIuZ5nDFBSQAoi
"""

"""Author:Yifei Pei"""
# Reference Codes for Yifei Pei, Ying Liu, Nam Ling, “Deep learning for lock-level compressive video sensing”, in 53rd IEEE International Symposium on Circuits and Systems (ISCAS 2020), Seville, Spain.
!pip install pandas
!pip install PyWavelets
!pip install keras
!pip install scipy

from zipfile import ZipFile
from keras.layers import Input, Dense
from keras.models import Model
from keras.optimizers import SGD
import glob
import numpy as np
import pandas as pd
import random
import scipy.fftpack
import pywt

folders = glob.glob('container/*')
folders.sort()
print(folders)

random.seed(4)

random.shuffle(folders)

training_set = []
testing_set = []

w, h = 352, 288
px = w*h

Y_list = []

for i in range(300):
    YUV = np.fromfile(folders[i],dtype = 'uint8')
    Y = YUV[0:w*h].reshape(h,w)
    Y_list.append(Y)

for i in range(300):
    if i < 210:
        training_set.append(Y_list[i])
    else:
        testing_set.append(Y_list[i])

training_block = []
testing_block = []

for i in range(210):
    img = training_set[i]
    for x in range(0, img.shape[0],16):
        for y in range(0, img.shape[1],16):
            training_block.append(img[x:x+16, y:y+16])
    

for i in range(90):
    img = testing_set[i]
    for x in range(0, img.shape[0],16):
        for y in range(0, img.shape[1],16):
            testing_block.append(img[x:x+16, y:y+16])

print(len(training_block))
print(len(testing_block))

(cA, cD) = pywt.dwt(np.eye(16), 'db1')

x = np.concatenate((cA, cD), axis=1)

def dwt2(array):
    return np.dot(np.dot(x, array), x.T)

def idwt2(array):
    return np.dot(np.dot(x.T, array), x)

vec_training_block_DWT = []
vec_testing_block_DWT = []

for i in range(83160):
    vec_training_block_DWT.append((dwt2(training_block[i])).reshape((256,)))           # Vectorize all training blocks

for i in range(35640):
    vec_testing_block_DWT.append((dwt2(testing_block[i])).reshape((256,)))              # Vectorize all testing blocks

def dct2(a):
    return scipy.fftpack.dct( scipy.fftpack.dct( a, axis=0, norm='ortho' ), axis=1, norm='ortho' )

def idct2(a):
    return scipy.fftpack.idct( scipy.fftpack.idct( a, axis=0 , norm='ortho'), axis=1 , norm='ortho')

vec_training_block_DCT = []
vec_testing_block_DCT = []

for i in range(83160):
    vec_training_block_DCT.append((dct2(training_block[i])).reshape((256,)))           # Vectorize all training blocks

for i in range(35640):
    vec_testing_block_DCT.append((dct2(testing_block[i])).reshape((256,)))              # Vectorize all testing blocks

vec_training_block = []
vec_testing_block = []

for i in range(83160):
    vec_training_block.append(training_block[i].reshape((256,)))           # Vectorize all training blocks

for i in range(35640):
    vec_testing_block.append(testing_block[i].reshape((256,)))              # Vectorize all testing blocks

'''Create Dummy Arrays to Save Train and Test Set for Pixels'''
X_train = numpy.random.randn(83160,256)
X_test = numpy.random.randn(35640,256)

'''Create Dummy Arrays to Save Train and Test Set for DCT Frequencies'''
X_train_DCT = numpy.random.randn(83160,256)
X_test_DCT = numpy.random.randn(35640,256)

'''Create Dummy Arrays to Save Train and Test Set for DWT Frequencies'''
X_train_DWT = numpy.random.randn(83160,256)
X_test_DWT = numpy.random.randn(35640,256)

for i in range(83160):
    X_train_DCT[i,:] = vec_training_block_DCT[i]          # All vectorized training blocks are saved in X_train
    
for i in range(35640):
    X_test_DCT[i,:] = vec_testing_block_DCT[i]          # All vectorized testing blocks are saved in X_test

for i in range(83160):
    X_train[i,:] = vec_training_block[i]          # All vectorized training blocks are saved in X_train
    
for i in range(35640):
    X_test[i,:] = vec_testing_block[i]          # All vectorized testing blocks are saved in X_test

for i in range(83160):
    X_train_DWT[i,:] = vec_training_block_DWT[i]          # All vectorized training blocks are saved in X_train
    
for i in range(35640):
    X_test_DWT[i,:] = vec_testing_block_DWT[i]          # All vectorized testing blocks are saved in X_test

def ANN(R, X_train, X_test):
    encoding_dim = int(R*256)  # 32 floats -> compression of factor 24.5, assuming the input is 784 floats
    
    input_img = Input(shape=(256,), name='encoder_input')
    
    x = input_img
    
    x = Dense(128, activation = None, bias = True)(x)
    
    latent = Dense(encoding_dim, name='latent_vector', activation = None, bias = True)(x)
    
    encoder = Model(input_img, latent, name='encoder')
    
    encoder.summary()
    
    latent_inputs = Input(shape=(encoding_dim,), name='decoder_input')
    
    reconstruction = Dense(256*12, activation = 'relu')(latent_inputs)
    
    outputs = Dense(256)(reconstruction)

    
    decoder = Model(latent_inputs, outputs, name='decoder')
    
    decoder.summary()
    
    autoencoder = Model(input_img, decoder(encoder(input_img)), name='autoencoder')
    
    autoencoder.summary()
    
    autoencoder.compile(loss='mse', optimizer='adam')
    
    history = autoencoder.fit(X_train, X_train,
                epochs=150,
                batch_size=64,
                shuffle=True,
                validation_data=(X_test, X_test))
    return autoencoder, encoder, decoder, history

'''Train the neural network based on pixel features'''
autoencoder010, encoder010, decoder010, history010 = ANN(0.10, X_train, X_test)

'''Train the neural network based on DCT frequencies'''
autoencoder010_DCT, encoder010_DCT, decoder010_DCT, history010_DCT = ANN(0.10, X_train_DCT, X_test_DCT)

'''Train the neural network based on DWT frequencies'''
autoencoder010_DWT, encoder010_DWT, decoder010_DWT, history010_DWT = ANN(0.10, X_train_DWT, X_test_DWT)